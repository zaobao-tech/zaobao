<h1>API Design Patterns</h1>
<p>Conventions and best practices for designing consistent, developer-friendly REST APIs.</p>
<h2>When to Activate</h2>
<ul>
<li>Designing new API endpoints</li>
<li>Reviewing existing API contracts</li>
<li>Adding pagination, filtering, or sorting</li>
<li>Implementing error handling for APIs</li>
<li>Planning API versioning strategy</li>
<li>Building public or partner-facing APIs</li>
</ul>
<h2>Resource Design</h2>
<h3>URL Structure</h3>
<pre><code># Resources are nouns, plural, lowercase, kebab-case
GET    /api/v1/users
GET    /api/v1/users/:id
POST   /api/v1/users
PUT    /api/v1/users/:id
PATCH  /api/v1/users/:id
DELETE /api/v1/users/:id

# Sub-resources for relationships
GET    /api/v1/users/:id/orders
POST   /api/v1/users/:id/orders

# Actions that don't map to CRUD (use verbs sparingly)
POST   /api/v1/orders/:id/cancel
POST   /api/v1/auth/login
POST   /api/v1/auth/refresh
</code></pre>
<h3>Naming Rules</h3>
<pre><code># GOOD
/api/v1/team-members          # kebab-case for multi-word resources
/api/v1/orders?status=active  # query params for filtering
/api/v1/users/123/orders      # nested resources for ownership

# BAD
/api/v1/getUsers              # verb in URL
/api/v1/user                  # singular (use plural)
/api/v1/team_members          # snake_case in URLs
/api/v1/users/123/getOrders   # verb in nested resource
</code></pre>
<h2>HTTP Methods and Status Codes</h2>
<h3>Method Semantics</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Idempotent</th>
<th>Safe</th>
<th>Use For</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>Yes</td>
<td>Yes</td>
<td>Retrieve resources</td>
</tr>
<tr>
<td>POST</td>
<td>No</td>
<td>No</td>
<td>Create resources, trigger actions</td>
</tr>
<tr>
<td>PUT</td>
<td>Yes</td>
<td>No</td>
<td>Full replacement of a resource</td>
</tr>
<tr>
<td>PATCH</td>
<td>No*</td>
<td>No</td>
<td>Partial update of a resource</td>
</tr>
<tr>
<td>DELETE</td>
<td>Yes</td>
<td>No</td>
<td>Remove a resource</td>
</tr>
</tbody>
</table>
<p>*PATCH can be made idempotent with proper implementation</p>
<h3>Status Code Reference</h3>
<pre><code># Success
200 OK                    — GET, PUT, PATCH (with response body)
201 Created               — POST (include Location header)
204 No Content            — DELETE, PUT (no response body)

# Client Errors
400 Bad Request           — Validation failure, malformed JSON
401 Unauthorized          — Missing or invalid authentication
403 Forbidden             — Authenticated but not authorized
404 Not Found             — Resource doesn't exist
409 Conflict              — Duplicate entry, state conflict
422 Unprocessable Entity  — Semantically invalid (valid JSON, bad data)
429 Too Many Requests     — Rate limit exceeded

# Server Errors
500 Internal Server Error — Unexpected failure (never expose details)
502 Bad Gateway           — Upstream service failed
503 Service Unavailable   — Temporary overload, include Retry-After
</code></pre>
<h3>Common Mistakes</h3>
<pre><code># BAD: 200 for everything
{ &quot;status&quot;: 200, &quot;success&quot;: false, &quot;error&quot;: &quot;Not found&quot; }

# GOOD: Use HTTP status codes semantically
HTTP/1.1 404 Not Found
{ &quot;error&quot;: { &quot;code&quot;: &quot;not_found&quot;, &quot;message&quot;: &quot;User not found&quot; } }

# BAD: 500 for validation errors
# GOOD: 400 or 422 with field-level details

# BAD: 200 for created resources
# GOOD: 201 with Location header
HTTP/1.1 201 Created
Location: /api/v1/users/abc-123
</code></pre>
<h2>Response Format</h2>
<h3>Success Response</h3>
<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;id&quot;: &quot;abc-123&quot;,
    &quot;email&quot;: &quot;alice@example.com&quot;,
    &quot;name&quot;: &quot;Alice&quot;,
    &quot;created_at&quot;: &quot;2025-01-15T10:30:00Z&quot;
  }
}
</code></pre>
<h3>Collection Response (with Pagination)</h3>
<pre><code class="language-json">{
  &quot;data&quot;: [
    { &quot;id&quot;: &quot;abc-123&quot;, &quot;name&quot;: &quot;Alice&quot; },
    { &quot;id&quot;: &quot;def-456&quot;, &quot;name&quot;: &quot;Bob&quot; }
  ],
  &quot;meta&quot;: {
    &quot;total&quot;: 142,
    &quot;page&quot;: 1,
    &quot;per_page&quot;: 20,
    &quot;total_pages&quot;: 8
  },
  &quot;links&quot;: {
    &quot;self&quot;: &quot;/api/v1/users?page=1&amp;per_page=20&quot;,
    &quot;next&quot;: &quot;/api/v1/users?page=2&amp;per_page=20&quot;,
    &quot;last&quot;: &quot;/api/v1/users?page=8&amp;per_page=20&quot;
  }
}
</code></pre>
<h3>Error Response</h3>
<pre><code class="language-json">{
  &quot;error&quot;: {
    &quot;code&quot;: &quot;validation_error&quot;,
    &quot;message&quot;: &quot;Request validation failed&quot;,
    &quot;details&quot;: [
      {
        &quot;field&quot;: &quot;email&quot;,
        &quot;message&quot;: &quot;Must be a valid email address&quot;,
        &quot;code&quot;: &quot;invalid_format&quot;
      },
      {
        &quot;field&quot;: &quot;age&quot;,
        &quot;message&quot;: &quot;Must be between 0 and 150&quot;,
        &quot;code&quot;: &quot;out_of_range&quot;
      }
    ]
  }
}
</code></pre>
<h3>Response Envelope Variants</h3>
<pre><code class="language-typescript">// Option A: Envelope with data wrapper (recommended for public APIs)
interface ApiResponse&lt;T&gt; {
  data: T;
  meta?: PaginationMeta;
  links?: PaginationLinks;
}

interface ApiError {
  error: {
    code: string;
    message: string;
    details?: FieldError[];
  };
}

// Option B: Flat response (simpler, common for internal APIs)
// Success: just return the resource directly
// Error: return error object
// Distinguish by HTTP status code
</code></pre>
<h2>Pagination</h2>
<h3>Offset-Based (Simple)</h3>
<pre><code>GET /api/v1/users?page=2&amp;per_page=20

# Implementation
SELECT * FROM users
ORDER BY created_at DESC
LIMIT 20 OFFSET 20;
</code></pre>
<p><strong>Pros:</strong> Easy to implement, supports &quot;jump to page N&quot;
<strong>Cons:</strong> Slow on large offsets (OFFSET 100000), inconsistent with concurrent inserts</p>
<h3>Cursor-Based (Scalable)</h3>
<pre><code>GET /api/v1/users?cursor=eyJpZCI6MTIzfQ&amp;limit=20

# Implementation
SELECT * FROM users
WHERE id &gt; :cursor_id
ORDER BY id ASC
LIMIT 21;  -- fetch one extra to determine has_next
</code></pre>
<pre><code class="language-json">{
  &quot;data&quot;: [...],
  &quot;meta&quot;: {
    &quot;has_next&quot;: true,
    &quot;next_cursor&quot;: &quot;eyJpZCI6MTQzfQ&quot;
  }
}
</code></pre>
<p><strong>Pros:</strong> Consistent performance regardless of position, stable with concurrent inserts
<strong>Cons:</strong> Cannot jump to arbitrary page, cursor is opaque</p>
<h3>When to Use Which</h3>
<table>
<thead>
<tr>
<th>Use Case</th>
<th>Pagination Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Admin dashboards, small datasets (&lt;10K)</td>
<td>Offset</td>
</tr>
<tr>
<td>Infinite scroll, feeds, large datasets</td>
<td>Cursor</td>
</tr>
<tr>
<td>Public APIs</td>
<td>Cursor (default) with offset (optional)</td>
</tr>
<tr>
<td>Search results</td>
<td>Offset (users expect page numbers)</td>
</tr>
</tbody>
</table>
<h2>Filtering, Sorting, and Search</h2>
<h3>Filtering</h3>
<pre><code># Simple equality
GET /api/v1/orders?status=active&amp;customer_id=abc-123

# Comparison operators (use bracket notation)
GET /api/v1/products?price[gte]=10&amp;price[lte]=100
GET /api/v1/orders?created_at[after]=2025-01-01

# Multiple values (comma-separated)
GET /api/v1/products?category=electronics,clothing

# Nested fields (dot notation)
GET /api/v1/orders?customer.country=US
</code></pre>
<h3>Sorting</h3>
<pre><code># Single field (prefix - for descending)
GET /api/v1/products?sort=-created_at

# Multiple fields (comma-separated)
GET /api/v1/products?sort=-featured,price,-created_at
</code></pre>
<h3>Full-Text Search</h3>
<pre><code># Search query parameter
GET /api/v1/products?q=wireless+headphones

# Field-specific search
GET /api/v1/users?email=alice
</code></pre>
<h3>Sparse Fieldsets</h3>
<pre><code># Return only specified fields (reduces payload)
GET /api/v1/users?fields=id,name,email
GET /api/v1/orders?fields=id,total,status&amp;include=customer.name
</code></pre>
<h2>Authentication and Authorization</h2>
<h3>Token-Based Auth</h3>
<pre><code># Bearer token in Authorization header
GET /api/v1/users
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...

# API key (for server-to-server)
GET /api/v1/data
X-API-Key: sk_live_abc123
</code></pre>
<h3>Authorization Patterns</h3>
<pre><code class="language-typescript">// Resource-level: check ownership
app.get(&quot;/api/v1/orders/:id&quot;, async (req, res) =&gt; {
  const order = await Order.findById(req.params.id);
  if (!order) return res.status(404).json({ error: { code: &quot;not_found&quot; } });
  if (order.userId !== req.user.id) return res.status(403).json({ error: { code: &quot;forbidden&quot; } });
  return res.json({ data: order });
});

// Role-based: check permissions
app.delete(&quot;/api/v1/users/:id&quot;, requireRole(&quot;admin&quot;), async (req, res) =&gt; {
  await User.delete(req.params.id);
  return res.status(204).send();
});
</code></pre>
<h2>Rate Limiting</h2>
<h3>Headers</h3>
<pre><code>HTTP/1.1 200 OK
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 95
X-RateLimit-Reset: 1640000000

# When exceeded
HTTP/1.1 429 Too Many Requests
Retry-After: 60
{
  &quot;error&quot;: {
    &quot;code&quot;: &quot;rate_limit_exceeded&quot;,
    &quot;message&quot;: &quot;Rate limit exceeded. Try again in 60 seconds.&quot;
  }
}
</code></pre>
<h3>Rate Limit Tiers</h3>
<table>
<thead>
<tr>
<th>Tier</th>
<th>Limit</th>
<th>Window</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td>Anonymous</td>
<td>30/min</td>
<td>Per IP</td>
<td>Public endpoints</td>
</tr>
<tr>
<td>Authenticated</td>
<td>100/min</td>
<td>Per user</td>
<td>Standard API access</td>
</tr>
<tr>
<td>Premium</td>
<td>1000/min</td>
<td>Per API key</td>
<td>Paid API plans</td>
</tr>
<tr>
<td>Internal</td>
<td>10000/min</td>
<td>Per service</td>
<td>Service-to-service</td>
</tr>
</tbody>
</table>
<h2>Versioning</h2>
<h3>URL Path Versioning (Recommended)</h3>
<pre><code>/api/v1/users
/api/v2/users
</code></pre>
<p><strong>Pros:</strong> Explicit, easy to route, cacheable
<strong>Cons:</strong> URL changes between versions</p>
<h3>Header Versioning</h3>
<pre><code>GET /api/users
Accept: application/vnd.myapp.v2+json
</code></pre>
<p><strong>Pros:</strong> Clean URLs
<strong>Cons:</strong> Harder to test, easy to forget</p>
<h3>Versioning Strategy</h3>
<pre><code>1. Start with /api/v1/ — don't version until you need to
2. Maintain at most 2 active versions (current + previous)
3. Deprecation timeline:
   - Announce deprecation (6 months notice for public APIs)
   - Add Sunset header: Sunset: Sat, 01 Jan 2026 00:00:00 GMT
   - Return 410 Gone after sunset date
4. Non-breaking changes don't need a new version:
   - Adding new fields to responses
   - Adding new optional query parameters
   - Adding new endpoints
5. Breaking changes require a new version:
   - Removing or renaming fields
   - Changing field types
   - Changing URL structure
   - Changing authentication method
</code></pre>
<h2>Implementation Patterns</h2>
<h3>TypeScript (Next.js API Route)</h3>
<pre><code class="language-typescript">import { z } from &quot;zod&quot;;
import { NextRequest, NextResponse } from &quot;next/server&quot;;

const createUserSchema = z.object({
  email: z.string().email(),
  name: z.string().min(1).max(100),
});

export async function POST(req: NextRequest) {
  const body = await req.json();
  const parsed = createUserSchema.safeParse(body);

  if (!parsed.success) {
    return NextResponse.json({
      error: {
        code: &quot;validation_error&quot;,
        message: &quot;Request validation failed&quot;,
        details: parsed.error.issues.map(i =&gt; ({
          field: i.path.join(&quot;.&quot;),
          message: i.message,
          code: i.code,
        })),
      },
    }, { status: 422 });
  }

  const user = await createUser(parsed.data);

  return NextResponse.json(
    { data: user },
    {
      status: 201,
      headers: { Location: `/api/v1/users/${user.id}` },
    },
  );
}
</code></pre>
<h3>Python (Django REST Framework)</h3>
<pre><code class="language-python">from rest_framework import serializers, viewsets, status
from rest_framework.response import Response

class CreateUserSerializer(serializers.Serializer):
    email = serializers.EmailField()
    name = serializers.CharField(max_length=100)

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = [&quot;id&quot;, &quot;email&quot;, &quot;name&quot;, &quot;created_at&quot;]

class UserViewSet(viewsets.ModelViewSet):
    serializer_class = UserSerializer
    permission_classes = [IsAuthenticated]

    def get_serializer_class(self):
        if self.action == &quot;create&quot;:
            return CreateUserSerializer
        return UserSerializer

    def create(self, request):
        serializer = CreateUserSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        user = UserService.create(**serializer.validated_data)
        return Response(
            {&quot;data&quot;: UserSerializer(user).data},
            status=status.HTTP_201_CREATED,
            headers={&quot;Location&quot;: f&quot;/api/v1/users/{user.id}&quot;},
        )
</code></pre>
<h3>Go (net/http)</h3>
<pre><code class="language-go">func (h *UserHandler) CreateUser(w http.ResponseWriter, r *http.Request) {
    var req CreateUserRequest
    if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil {
        writeError(w, http.StatusBadRequest, &quot;invalid_json&quot;, &quot;Invalid request body&quot;)
        return
    }

    if err := req.Validate(); err != nil {
        writeError(w, http.StatusUnprocessableEntity, &quot;validation_error&quot;, err.Error())
        return
    }

    user, err := h.service.Create(r.Context(), req)
    if err != nil {
        switch {
        case errors.Is(err, domain.ErrEmailTaken):
            writeError(w, http.StatusConflict, &quot;email_taken&quot;, &quot;Email already registered&quot;)
        default:
            writeError(w, http.StatusInternalServerError, &quot;internal_error&quot;, &quot;Internal error&quot;)
        }
        return
    }

    w.Header().Set(&quot;Location&quot;, fmt.Sprintf(&quot;/api/v1/users/%s&quot;, user.ID))
    writeJSON(w, http.StatusCreated, map[string]any{&quot;data&quot;: user})
}
</code></pre>
<h2>API Design Checklist</h2>
<p>Before shipping a new endpoint:</p>
<ul>
<li>[ ] Resource URL follows naming conventions (plural, kebab-case, no verbs)</li>
<li>[ ] Correct HTTP method used (GET for reads, POST for creates, etc.)</li>
<li>[ ] Appropriate status codes returned (not 200 for everything)</li>
<li>[ ] Input validated with schema (Zod, Pydantic, Bean Validation)</li>
<li>[ ] Error responses follow standard format with codes and messages</li>
<li>[ ] Pagination implemented for list endpoints (cursor or offset)</li>
<li>[ ] Authentication required (or explicitly marked as public)</li>
<li>[ ] Authorization checked (user can only access their own resources)</li>
<li>[ ] Rate limiting configured</li>
<li>[ ] Response does not leak internal details (stack traces, SQL errors)</li>
<li>[ ] Consistent naming with existing endpoints (camelCase vs snake_case)</li>
<li>[ ] Documented (OpenAPI/Swagger spec updated)</li>
</ul>
